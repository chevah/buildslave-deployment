#!/bin/sh

### BEGIN INIT INFO
# Provides:          buildslave
# Required-Start:    $local_fs $remote_fs $network $syslog
# Required-Stop:     $local_fs $remote_fs $network $syslog
# chkconfig:         2345 99 01
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Buildbot slave for the Chevah project
# Description:       Buildbot slave for the Chevah project
### END INIT INFO

# FreeBSD keywords:
# PROVIDE: buildslave
# REQUIRE: LOGIN
# KEYWORD: shutdown

#
# Make sure sudo, bash, and a cURL-enabled git are present in root's PATH.
# Also, a GNU-compatible patch is needed in /usr/bin (buildbot's limitation).
#

# This file should live as /etc/init.d/buildslave
# For AIX that would be /etc/rc.d/init.d/buildslave
# For HP-UX that would be /sbin/init.d/buildslave
# For FreeBSD that would be /usr/local/etc/rc.d/buildslave
# For OpenBSD that would be /etc/rc.d/buildslave

# Debian/Ubuntu usage (as root).
#  * enable service at boot:
#      update-rc.d buildslave defaults
#  * manually start the service:
#      service buildslave start
#  * manually stop the service:
#      service buildslave stop
#
# RedHat/CentOS/SUSE usage (as root).
#  * enable service at boot:
#      chkconfig --add buildslave
#  * manually start the service:
#      service buildslave start
#  * manually stop the service:
#      service buildslave stop
#
# AIX usage (as root).
#  * enable service at boot:
#      ln -s /etc/rc.d/init.d/buildslave /etc/rc.d/rc2.d/S90buildslave
#  * manually start the service:
#      /etc/rc.d/init.d/buildslave start
#  * manually stop the service:
#      /etc/rc.d/init.d/buildslave stop
#
# Solaris usage (as root).
#  * enable service at boot:
#      ln -s /etc/init.d/buildslave /etc/rc3.d/S90buildslave
#  * manually start the service:
#      /etc/init.d/buildslave start
#  * manually stop the service:
#      /etc/init.d/buildslave stop
#
# HP-UX usage (as root).
#  * enable service at boot:
#      ln -s /sbin/init.d/buildslave /sbin/rc3.d/S900buildslave
#  * manually start the service:
#      /sbin/init.d/buildslave start
#  * manually stop the service:
#      /sbin/init.d/buildslave stop
#
# FreeBSD usage (as root).
#  * enable service at boot:
#      echo 'buildslave_enable="YES"' >> /etc/rc.conf
#  * manually start the service:
#      service buildslave start
#  * manually stop the service:
#      service buildslave stop
#
# OpenBSD usage (as root).
#  * enable service at boot:
#      rcctl set buildslave status on
#  * manually start the service:
#      /etc/rc.d/buildslave start
#  * manually stop the service:
#      /etc/rc.d/buildslave stop

# Do NOT "set -e".

DAEMON_USER="buildslave"
INSTALL_ROOT="/srv/buildslave/runtime/"
SERVICE_NAME="Chevah buildbot slave"
PID_FILE=$INSTALL_ROOT/"build-*/slave/twistd.pid"
DAEMON_BIN="./brink.sh"
DAEMON_LOGDIR="/var/log/buildslave"
DAEMON_NAME="python"
TIMEOUT_SECONDS="10"

# For HP-UX's ps to accept '-o' arguments, the 2003 UNIX standard has to be set.
# Also, PATH should be exported to use external utilities during boot.
# Logs should go to /var/adm on HP-UX.
if [ x`uname` = x'HP-UX' ]; then
    export UNIX_STD=2003 PATH="/usr/sbin:/usr/bin:/sbin:/usr/local/bin"
    DAEMON_LOGDIR="/var/adm/buildslave"
fi

# For FreeBSD and OpenBSD, make sure /usr/local/bin is in the path for brink.sh.
if [ x`uname` = x'FreeBSD' -o x`uname` = x'OpenBSD' ]; then
    export PATH="$PATH:/usr/local/bin"
fi

# We use custom curl/git binaries for SLES 11 to support TLS 1.2 for GitHub.
# Installations without Security Module also use custom OpenSSL 1.0.1.
if [ -s /etc/SuSE-release ]; then
    if [ x`grep VERSION /etc/SuSE-release | cut -d' ' -f3` = x'11' ]; then
        export LD_LIBRARY_PATH="/usr/local/lib64:/usr/local/lib"
        export PATH=/usr/local/bin:$PATH
    fi
fi

#
# Starts the service in debug mode without any checks or redirecting outputs.
#
debug_service() {
    printf "Debugging $SERVICE_NAME services: "
    cd $INSTALL_ROOT
    sudo -u $DAEMON_USER $DAEMON_BIN debug
}

#
# Function used to check for a predetermined number of seconds if a certain
# error code is generated by status_service(). It takes two arguments: the
# error code to check for and the command to execute otherwise.
#
timedout_check() {
    error_code="$1"
    else_command="$2"

    i=0
    while [ $i -lt $TIMEOUT_SECONDS ]; do
        status_service 2>/dev/null
        if [ $? -eq $error_code ]; then
            printf " Done.\n"
            exit 0
        else
            $else_command
        fi
        sleep 1
        printf "."
        i=`expr $i + 1`
    done
}

#
# Starts the service if properly stopped and waits for it to launch
# successfully for a predefined number of seconds.
#
start_service() {
    status_service 2>/dev/null
    case $? in
        0)
            printf "$SERVICE_NAME is already running, nothing to start.\n"
            exit 0
            ;;
        1|4)
            printf "$SERVICE_NAME was not properly stopped, not starting!\n"
            exit 1
            ;;
    esac
    printf "Starting $SERVICE_NAME: "
    # The brink's start target will do the rest.
    cd $INSTALL_ROOT
    DAEMON_OUT="$DAEMON_LOGDIR/stdout.log"
    DAEMON_ERR="$DAEMON_LOGDIR/stderr.log"
    # Update brink's deps.
    sudo -u $DAEMON_USER $DAEMON_BIN deps >>"$DAEMON_OUT" 2>>"$DAEMON_ERR"
    sudo -u $DAEMON_USER $DAEMON_BIN start >>"$DAEMON_OUT" 2>>"$DAEMON_ERR"
    timedout_check 0 "true"
    printf "\nCould not properly start $SERVICE_NAME!\n" >&2
    exit 1
}

#
# Stops the service if properly running and waits for it to stop
# successfully for a predefined number of seconds.
#
stop_service() {
    status_service
    case $? in
        3)
            printf "$SERVICE_NAME is not running, nothing to stop.\n"
            exit 0
            ;;
        1|4)
            printf "$SERVICE_NAME is not properly running, not stopping!\n"
            exit 1
            ;;
    esac
    printf "Stopping $SERVICE_NAME: "
    timedout_check 3 "kill $SAVED_PID"
    printf "\nCould not properly stop $SERVICE_NAME!\n" >&2
    exit 1
}

#
# Forcefully stops the service by attempting to kill all running processes.
# Useful when the PID file is not present anymore on the disk. Or when a
# -9/-SIGKILL parameter is needed for killing the running processes.
#
forcedstop_service() {
    status_service
    case $? in
        3)
            printf "$SERVICE_NAME is not running, nothing to forcefully stop.\n"
            exit 0
            ;;
        0)
            printf "$SERVICE_NAME is running fine, initiating normal stop...\n"
            $0 stop
            exit $?
            ;;
    esac
    printf "$SERVICE_NAME is not properly running, killing it nicely first: "
    timedout_check 3 "kill $IN_MEM_PIDS"
    printf "$SERVICE_NAME still running, killing it forcefully: "
    timedout_check 3 "kill -9 $IN_MEM_PIDS"
    printf "\nCould not forcefully stop $SERVICE_NAME!\n" >&2
    exit 1
}

#
# This implements a crude but portable status action for the init script
# without using LSB functions, although respecting the LSB 4.1 error codes.
#
status_service() {
    # A portable ps invocation to get the pids and commands for all processes
    # running as relevant user (without the usual ps headers).
    in_mem_pids_comms=`ps -U $DAEMON_USER -o pid= -o comm= | grep "$DAEMON_NAME"`
    # Check for processes running under the relevant name.
    if [ -z "$in_mem_pids_comms" ] ; then
        printf "No $DAEMON_NAME process is running as user $DAEMON_USER.\n" >&2
        return 3
    fi
    IN_MEM_PIDS=`printf "$in_mem_pids_comms" | awk '{print $1}' | xargs`
    # Check for problems related to the PID read from $PID_FILE.
    # Do not quote $PID_FILE in the buildbot script, it needs to be expanded.
    if [ ! -s $PID_FILE ]; then
        printf "Problems reading PID from file $PID_FILE.\n" >&2
        return 4
    fi
    SAVED_PID=`cat $PID_FILE`
    matched_pid=`printf "$in_mem_pids_comms" | awk '{print $1}' | grep "$SAVED_PID"`
    if [ ! "$matched_pid" = "$SAVED_PID" ]; then
        printf "PID from $PID_FILE doesn't match running processes.\n" >&2
        return 4
    fi
    # Check that the corresponding process is responding.
    if kill -0 "$SAVED_PID"; then
        (exit 0)
    else
        printf "$SERVICE_NAME is not responding or wrong PID: $SAVED_PID.\n" >&2
        return 1
    fi
}



#
# main
#

# A crude check for a sane installation and configuration.
if [ ! -x $INSTALL_ROOT/$DAEMON_BIN ]; then
    printf "$DAEMON_BIN executable not present!\n" >&2
    exit 5
fi

# If necessary, create a sub-dir in /var/log for logging stdout and stderr.
if [ ! -d "$DAEMON_LOGDIR" ]; then
    printf "Log dir $DAEMON_LOGDIR not found, creating...\n"
    mkdir "$DAEMON_LOGDIR"
fi

# Check for the user's existence.
if id $DAEMON_USER >/dev/null 2>&1; then
    # Make sure the log sub-dir is owned by our user, recursively.
    chown -R $DAEMON_USER "$DAEMON_LOGDIR"
else
    printf "$DAEMON_USER user not present!\n" >&2
    exit 6
fi

# Basic hackish support for OpenBSD's rcctl and FreeBSD.
case "$1" in
    # For OpenBSD's rctl, used to force the start, even if not enabled at boot.
    -f)
        shift
        ;;
    # Used in OpenBSD for debugging, but we only do it for starting.
    -d)
        debug_service
        ;;
    # Here we map our (LSB-specific) error codes to those needed for rcctl.
    check)
        status_service 2> /dev/null
        ret_val=$?
        if [ $ret_val -eq 3 ]; then
            exit 1
        fi
        exit $ret_val
        ;;
    # Minimal support for FreeBSD's service 'rcvar' and 'enabled' parameters.
    rcvar|enabled)
        if [ "$1" = "rcvar" ]; then
            myprintf=printf
        else
            myprintf=true
        fi
        if grep --quiet 'buildslave_enable="YES' /etc/rc.conf; then
            $myprintf 'buildslave_enable="YES"\n'
            exit 0
        else
            $myprintf 'buildslave_enable="NO"\n'
            exit 1
        fi
        ;;
esac

# Do not use stop_service() and start_service() for restart/force-reload.
# The one* and fast* actions are specific to FreeBSD.
# The start_* actions are specific to HP-UX.
case "$@" in
    start|onestart|faststart)
        start_service
        ;;
    stop|onestop|faststop)
        stop_service
        ;;
    restart|onerestart|force-reload)
        $0 stop
        $0 start
        ;;
    force-stop)
        forcedstop_service
        ;;
    status|onestatus)
        status_service
        ret_val=$?
        case $ret_val in
            0)
                printf "$SERVICE_NAME is running with PID $SAVED_PID.\n"
                ;;
            3)
                printf "$SERVICE_NAME is not running!\n"
                ;;
            *)
                printf "$SERVICE_NAME is not properly running!\n"
                ;;
        esac
        exit $ret_val
        ;;
    debug)
        debug_service
        ;;
    start_msg)
        # Emit a _short_ message relating to running this script with the "start"
        # argument; this message appears as part of the checklist in HP-UX.
        printf "Starting $SERVICE_NAME"
        ;;

    stop_msg)
        # Emit a _short_ message relating to running this script with the "stop"
        # argument; this message appears as part of the checklist in HP-UX.
        printf "Stopping $SERVICE_NAME"
        ;;
    *)
        printf "Usage: $0 {start|stop|restart|force-reload|force-stop|status|debug}\n" >&2
        exit 2
        ;;
esac
